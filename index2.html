
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF & Image Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/17.0.2/umd/react.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.2/umd/react-dom.development.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://unpkg.com/pdfjs-dist@2.10.377/build/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .App {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background-color: #3f51b5;
            color: white;
            padding: 1rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        
        .sidebar {
            width: 250px;
            background-color: #2c3e50;
            color: white;
            padding: 1rem;
            overflow-y: auto;
        }
        
        .sidebar h3 {
            margin-bottom: 1rem;
            border-bottom: 1px solid #34495e;
            padding-bottom: 0.5rem;
        }
        
        .tool-section {
            margin-bottom: 1.5rem;
        }
        
        .tool-section h4 {
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }
        
        .tool-section input, 
        .tool-section select, 
        .tool-section button {
            margin: 0.25rem 0;
            padding: 0.5rem;
            width: 100%;
            border: none;
            border-radius: 4px;
        }
        
        .tool-section button {
            background-color: #3498db;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }
        
        .tool-section button:hover {
            background-color: #2980b9;
        }
        
        .button-group {
            display: flex;
            gap: 0.5rem;
        }
        
        .button-group button {
            flex: 1;
        }
        
        .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .input-group input {
            flex: 1;
        }
        
        .slider-group {
            margin: 0.5rem 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 0.25rem;
        }
        
        .slider-group input[type="range"] {
            width: 100%;
        }
        
        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            overflow: hidden;
        }
        
        .toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: white;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }
        
        .toolbar button {
            padding: 0.5rem 1rem;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .toolbar button:hover {
            background-color: #2980b9;
        }
        
        .toolbar button.active {
            background-color: #2980b9;
            font-weight: bold;
        }
        
        .file-uploader {
            margin-bottom: 1rem;
            padding: 1rem;
            border: 2px dashed #3498db;
            border-radius: 4px;
            text-align: center;
        }
        
        .file-uploader input {
            display: none;
        }
        
        .file-uploader label {
            display: inline-block;
            padding: 0.5rem 1rem;
            background-color: #3498db;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .file-uploader label:hover {
            background-color: #2980b9;
        }
        
        .editor-canvas {
            flex: 1;
            background-color: #ecf0f1;
            border-radius: 4px;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .canvas-container {
            max-width: 800px;
            max-height: 600px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            margin: 1rem;
        }
        
        .pdf-page {
            border: 1px solid #ccc;
            margin: 0.5rem;
            background-color: white;
        }
        
        .image-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .image-container img {
            max-width: 100%;
            max-height: 600px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .page-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 1rem;
            gap: 1rem;
        }
        
        .page-controls button {
            padding: 0.5rem 1rem;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .page-controls span {
            padding: 0.5rem;
            font-weight: bold;
        }
        
        .no-file {
            color: #7f8c8d;
            font-style: italic;
        }
        
        .loading {
            text-align: center;
            padding: 2rem;
            color: #7f8c8d;
        }
        
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: auto;
                max-height: 30vh;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // Global variables for processing
        let pdfjsLib = window['pdfjs-dist/build/pdf'];
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.worker.min.js';
        
        const { PDFDocument } = window.pdfLib;
        let fabric = window.fabric;
        let currentCanvas = null;
        let currentPdfDoc = null;
        let currentPageNumber = 1;
        let totalPages = 0;
        
        // Main App Component
        function App() {
            const [currentFile, setCurrentFile] = useState(null);
            const [fileType, setFileType] = useState('');
            const [activeTool, setActiveTool] = useState('select');
            const [isLoading, setIsLoading] = useState(false);
            const [currentPage, setCurrentPage] = useState(1);
            
            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                setIsLoading(true);
                setCurrentFile(file);
                const type = file.type.split('/')[0];
                setFileType(type);
                
                if (type === 'application' || file.name.toLowerCase().endsWith('.pdf')) {
                    await processPDF(file);
                } else {
                    processImage(file);
                }
                
                setIsLoading(false);
            };
            
            const processPDF = async (file) => {
                const fileUrl = URL.createObjectURL(file);
                const loadingTask = pdfjsLib.getDocument(fileUrl);
                const pdf = await loadingTask.promise;
                currentPdfDoc = pdf;
                totalPages = pdf.numPages;
                setCurrentPage(1);
                
                // Render the first page
                renderPDFPage(pdf, 1);
            };
            
            const renderPDFPage = async (pdf, pageNumber) => {
                const page = await pdf.getPage(pageNumber);
                const viewport = page.getViewport({ scale: 1.5 });
                
                // Prepare canvas
                const canvas = document.getElementById('pdf-canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                // Render PDF page into canvas
                const renderContext = {
                    canvasContext: context,
                    viewport: viewport
                };
                await page.render(renderContext).promise;
            };
            
            const processImage = (file) => {
                const imageUrl = URL.createObjectURL(file);
                const img = document.getElementById('image-element');
                img.src = imageUrl;
                
                // Initialize fabric canvas when image loads
                img.onload = () => {
                    if (currentCanvas) {
                        currentCanvas.dispose();
                    }
                    currentCanvas = new fabric.Canvas('image-canvas');
                    currentCanvas.setWidth(img.naturalWidth);
                    currentCanvas.setHeight(img.naturalHeight);
                    
                    const fabricImage = new fabric.Image(img);
                    fabricImage.scaleToWidth(currentCanvas.getWidth());
                    currentCanvas.setBackgroundImage(fabricImage, currentCanvas.renderAll.bind(currentCanvas));
                };
            };
            
            const handleToolChange = (tool) => {
                setActiveTool(tool);
                
                // Handle specific tool actions
                if (currentCanvas && tool === 'draw') {
                    currentCanvas.isDrawingMode = true;
                    currentCanvas.freeDrawingBrush.color = '#000000';
                    currentCanvas.freeDrawingBrush.width = 5;
                } else if (currentCanvas) {
                    currentCanvas.isDrawingMode = false;
                }
            };
            
            const handlePageChange = async (newPage) => {
                if (newPage >= 1 && newPage <= totalPages && currentPdfDoc) {
                    setCurrentPage(newPage);
                    await renderPDFPage(currentPdfDoc, newPage);
                }
            };
            
            const handlePDFAction = async (action, options) => {
                if (!currentFile) return;
                
                setIsLoading(true);
                
                try {
                    let result;
                    
                    switch (action) {
                        case 'addText':
                            result = await addTextToPDF(options);
                            break;
                        case 'rotate':
                            result = await rotatePDFPage(options);
                            break;
                        case 'extractPage':
                            result = await extractPDFPage(options);
                            break;
                        case 'protect':
                            result = await protectPDF(options);
                            break;
                        case 'addWatermark':
                            result = await addWatermarkToPDF(options);
                            break;
                        default:
                            console.log('Unknown PDF action:', action);
                    }
                    
                    if (result) {
                        // Create download link
                        const link = document.createElement('a');
                        link.href = result;
                        link.download = `edited-${currentFile.name}`;
                        link.click();
                    }
                } catch (error) {
                    alert('Error processing PDF: ' + error.message);
                }
                
                setIsLoading(false);
            };
            
            const addTextToPDF = async (options) => {
                const arrayBuffer = await currentFile.arrayBuffer();
                const pdfDoc = await PDFDocument.load(arrayBuffer);
                
                const pages = pdfDoc.getPages();
                const pageIndex = options.pageNumber - 1;
                
                if (pageIndex >= 0 && pageIndex < pages.length) {
                    pages[pageIndex].drawText(options.text, {
                        x: 50,
                        y: pages[pageIndex].getHeight() - 100,
                        size: options.fontSize || 16,
                        color: pdfDoc.getOrCreateRGBColor(
                            parseInt(options.fontColor?.substring(1, 3), 16) / 255,
                            parseInt(options.fontColor?.substring(3, 5), 16) / 255,
                            parseInt(options.fontColor?.substring(5, 7), 16) / 255
                        ),
                    });
                }
                
                const pdfBytes = await pdfDoc.save();
                return URL.createObjectURL(new Blob([pdfBytes], { type: 'application/pdf' }));
            };
            
            const rotatePDFPage = async (options) => {
                const arrayBuffer = await currentFile.arrayBuffer();
                const pdfDoc = await PDFDocument.load(arrayBuffer);
                
                const pages = pdfDoc.getPages();
                const pageIndex = options.pageNumber - 1;
                
                if (pageIndex >= 0 && pageIndex < pages.length) {
                    const page = pages[pageIndex];
                    const rotation = page.getRotation();
                    const degrees = rotation.degrees;
                    const newDegrees = options.direction === 'right' 
                        ? (degrees + 90) % 360 
                        : (degrees - 90 + 360) % 360;
                    
                    page.setRotation(pdfDoc.getRotationDegrees(newDegrees));
                }
                
                const pdfBytes = await pdfDoc.save();
                return URL.createObjectURL(new Blob([pdfBytes], { type: 'application/pdf' }));
            };
            
            const extractPDFPage = async (options) => {
                const arrayBuffer = await currentFile.arrayBuffer();
                const pdfDoc = await PDFDocument.load(arrayBuffer);
                
                const newDoc = await PDFDocument.create();
                const [copiedPage] = await newDoc.copyPages(pdfDoc, [options.pageNumber - 1]);
                newDoc.addPage(copiedPage);
                
                const pdfBytes = await newDoc.save();
                return URL.createObjectURL(new Blob([pdfBytes], { type: 'application/pdf' }));
            };
            
            const protectPDF = async (options) => {
                const arrayBuffer = await currentFile.arrayBuffer();
                const pdfDoc = await PDFDocument.load(arrayBuffer);
                
                const pdfBytes = await pdfDoc.save({
                    encrypt: {
                        userPassword: options.password,
                        ownerPassword: options.password,
                        userPermissions: {
                            printing: 'lowResolution',
                            modifying: false,
                            copying: false,
                            annotating: true,
                            fillingForms: true,
                            contentAccessibility: true,
                            documentAssembly: false,
                        },
                    },
                });
                
                return URL.createObjectURL(new Blob([pdfBytes], { type: 'application/pdf' }));
            };
            
            const addWatermarkToPDF = async (options) => {
                const arrayBuffer = await currentFile.arrayBuffer();
                const pdfDoc = await PDFDocument.load(arrayBuffer);
                
                const pages = pdfDoc.getPages();
                const helveticaFont = await pdfDoc.embedFont('Helvetica');
                
                pages.forEach(page => {
                    const { width, height } = page.getSize();
                    const opacity = 0.3;
                    
                    if (options.position === 'diagonal') {
                        const textWidth = helveticaFont.widthOfTextAtSize(options.text, 60);
                        const textHeight = helveticaFont.heightAtSize(60);
                        
                        page.drawText(options.text, {
                            x: width / 2 - textWidth / 2,
                            y: height / 2 - textHeight / 2,
                            size: 60,
                            font: helveticaFont,
                            opacity,
                            rotate: Math.PI / 4,
                        });
                    } else if (options.position === 'horizontal') {
                        const textWidth = helveticaFont.widthOfTextAtSize(options.text, 40);
                        page.drawText(options.text, {
                            x: width / 2 - textWidth / 2,
                            y: height - 100,
                            size: 40,
                            font: helveticaFont,
                            opacity,
                        });
                    } else if (options.position === 'vertical') {
                        const textWidth = helveticaFont.widthOfTextAtSize(options.text, 40);
                        const textHeight = helveticaFont.heightAtSize(40);
                        
                        page.drawText(options.text, {
                            x: width - 100,
                            y: height / 2 - textHeight / 2,
                            size: 40,
                            font: helveticaFont,
                            opacity,
                            rotate: Math.PI / 2,
                        });
                    }
                });
                
                const pdfBytes = await pdfDoc.save();
                return URL.createObjectURL(new Blob([pdfBytes], { type: 'application/pdf' }));
            };
            
            const handleImageAction = (action, options) => {
                if (!currentCanvas || !currentFile) return;
                
                setIsLoading(true);
                
                try {
                    switch (action) {
                        case 'adjust':
                            adjustImage(options);
                            break;
                        case 'rotate':
                            rotateImage(options);
                            break;
                        case 'crop':
                            cropImage(options);
                            break;
                        case 'addText':
                            addTextToImage(options);
                            break;
                        case 'filter':
                            applyFilter(options);
                            break;
                        case 'resize':
                            resizeImage(options);
                            break;
                        case 'draw':
                            drawOnImage(options);
                            break;
                        default:
                            console.log('Unknown image action:', action);
                    }
                } catch (error) {
                    alert('Error processing image: ' + error.message);
                }
                
                setIsLoading(false);
            };
            
            const adjustImage = (options) => {
                const imgObj = currentCanvas.backgroundImage;
                imgObj.filters = [];
                
                if (options.brightness) {
                    imgObj.filters.push(new fabric.Image.filters.Brightness({ 
                        brightness: (options.brightness - 100) / 100 
                    }));
                }
                
                if (options.contrast) {
                    imgObj.filters.push(new fabric.Image.filters.Contrast({ 
                        contrast: (options.contrast - 100) / 100 
                    }));
                }
                
                if (options.saturation) {
                    imgObj.filters.push(new fabric.Image.filters.Saturation({ 
                        saturation: (options.saturation - 100) / 100 
                    }));
                }
                
                imgObj.applyFilters();
                currentCanvas.renderAll();
            };
            
            const rotateImage = (options) => {
                const imgObj = currentCanvas.backgroundImage;
                const currentAngle = imgObj.angle || 0;
                const newAngle = options.direction === 'right' 
                    ? currentAngle + 90 
                    : currentAngle - 90;
                
                imgObj.rotate(newAngle);
                currentCanvas.renderAll();
            };
            
            const cropImage = (options) => {
                // This is a simplified implementation
                // In a real app, you would let users select crop area
                const imgObj = currentCanvas.backgroundImage;
                imgObj.clipPath = new fabric.Rect({
                    left: 50,
                    top: 50,
                    width: imgObj.width / 2,
                    height: imgObj.height / 2
                });
                
                currentCanvas.renderAll();
            };
            
            const addTextToImage = (options) => {
                const text = new fabric.Textbox(options.text, {
                    left: options.position?.x || 50,
                    top: options.position?.y || 50,
                    fontSize: options.fontSize || 20,
                    fill: options.color || '#000000'
                });
                
                currentCanvas.add(text);
                currentCanvas.setActiveObject(text);
            };
            
            const applyFilter = (options) => {
                const imgObj = currentCanvas.backgroundImage;
                imgObj.filters = [];
                
                switch (options.filter) {
                    case 'grayscale':
                        imgObj.filters.push(new fabric.Image.filters.Grayscale());
                        break;
                    case 'sepia':
                        imgObj.filters.push(new fabric.Image.filters.Sepia());
                        break;
                    case 'invert':
                        imgObj.filters.push(new fabric.Image.filters.Invert());
                        break;
                    case 'blur':
                        imgObj.filters.push(new fabric.Image.filters.Blur({ 
                            blur: 0.5 
                        }));
                        break;
                    case 'sharpen':
                        imgObj.filters.push(new fabric.Image.filters.Convolute({
                            matrix: [0, -1, 0, -1, 5, -1, 0, -1, 0]
                        }));
                        break;
                }
                
                imgObj.applyFilters();
                currentCanvas.renderAll();
            };
            
            const resizeImage = (options) => {
                const imgObj = currentCanvas.backgroundImage;
                imgObj.scaleToWidth(options.width);
                currentCanvas.renderAll();
            };
            
            const drawOnImage = (options) => {
                // Drawing is handled by fabric's drawing mode
                // This function just ensures the mode is active
                currentCanvas.isDrawingMode = true;
                currentCanvas.freeDrawingBrush.color = options.color || '#000000';
                currentCanvas.freeDrawingBrush.width = options.width || 5;
            };
            
            const exportImage = () => {
                if (!currentCanvas) return;
                
                // Create a temporary canvas to export the image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = currentCanvas.getWidth();
                tempCanvas.height = currentCanvas.getHeight();
                
                const tempCtx = tempCanvas.getContext('2d');
                
                // Draw the background image
                const bgImg = currentCanvas.backgroundImage;
                if (bgImg) {
                    tempCtx.drawImage(bgImg._element, 0, 0, tempCanvas.width, tempCanvas.height);
                }
                
                // Draw all objects on top
                currentCanvas.getObjects().forEach(obj => {
                    tempCanvas.add(obj);
                });
                
                // Export as PNG
                const dataUrl = tempCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = dataUrl;
                link.download = `edited-${currentFile.name.split('.')[0]}.png`;
                link.click();
            };
            
            return (
                <div className="App">
                    <header className="header">
                        <h1>PDF & Image Editor</h1>
                    </header>
                    
                    <div className="main-container">
                        <aside className="sidebar">
                            {fileType === 'application' || currentFile?.name?.toLowerCase().endsWith('.pdf') ? (
                                <PDFTools 
                                    onAction={handlePDFAction} 
                                    currentPage={currentPage} 
                                />
                            ) : fileType === 'image' ? (
                                <ImageTools 
                                    onAction={handleImageAction} 
                                    onExport={exportImage}
                                />
                            ) : (
                                <div className="no-file">
                                    <p>Upload a PDF or image file to start editing</p>
                                </div>
                            )}
                        </aside>
                        
                        <main className="editor-container">
                            <div className="toolbar">
                                <button 
                                    className={activeTool === 'select' ? 'active' : ''}
                                    onClick={() => handleToolChange('select')}
                                >
                                    Select
                                </button>
                                {fileType === 'image' && (
                                    <>
                                        <button 
                                            className={activeTool === 'draw' ? 'active' : ''}
                                            onClick={() => handleToolChange('draw')}
                                        >
                                            Draw
                                        </button>
                                        <button 
                                            className={activeTool === 'text' ? 'active' : ''}
                                            onClick={() => handleToolChange('text')}
                                        >
                                            Add Text
                                        </button>
                                        <button 
                                            className={activeTool === 'crop' ? 'active' : ''}
                                            onClick={() => handleToolChange('crop')}
                                        >
                                            Crop
                                        </button>
                                    </>
                                )}
                            </div>
                            
                            <div className="file-uploader">
                                <label htmlFor="file-input">Choose File</label>
                                <input 
                                    id="file-input" 
                                    type="file" 
                                    accept=".pdf,image/*" 
                                    onChange={handleFileUpload} 
                                />
                                <p>{currentFile ? `File: ${currentFile.name}` : 'No file selected'}</p>
                            </div>
                            
                            <div className="editor-canvas">
                                {isLoading ? (
                                    <div className="loading">
                                        <p>Loading file...</p>
                                    </div>
                                ) : currentFile ? (
                                    fileType === 'application' || currentFile.name.toLowerCase().endsWith('.pdf') ? (
                                        <div className="canvas-container">
                                            <canvas id="pdf-canvas" />
                                            {totalPages > 1 && (
                                                <div className="page-controls">
                                                    <button onClick={() => handlePageChange(currentPage - 1)} disabled={currentPage <= 1}>
                                                        Previous
                                                    </button>
                                                    <span>Page {currentPage} of {totalPages}</span>
                                                    <button onClick={() => handlePageChange(currentPage + 1)} disabled={currentPage >= totalPages}>
                                                        Next
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    ) : (
                                        <div className="image-container">
                                            <img id="image-element" alt="Upload to preview" style={{ display: 'none' }} />
                                            <canvas id="image-canvas" width="800" height="600"></canvas>
                                        </div>
                                    )
                                ) : (
                                    <div className="no-file">
                                        <p>Upload a file to begin editing</p>
                                    </div>
                                )}
                            </div>
                        </main>
                    </div>
                </div>
            );
        }
        
        // PDF Tools Component
        function PDFTools({ onAction, currentPage }) {
            const [text, setText] = useState('');
            const [fontSize, setFontSize] = useState(16);
            const [fontColor, setFontColor] = useState('#000000');
            const [password, setPassword] = useState('');
            const [watermarkText, setWatermarkText] = useState('DRAFT');
            const [watermarkPosition, setWatermarkPosition] = useState('diagonal');
            
            const handleAddText = () => {
                if (!text) {
                    alert('Please enter text to add');
                    return;
                }
                
                onAction('addText', { 
                    text, 
                    fontSize, 
                    fontColor, 
                    pageNumber: currentPage 
                });
            };
            
            const handleRotate = (direction) => {
                onAction('rotate', { 
                    direction, 
                    pageNumber: currentPage 
                });
            };
            
            const handleExtractPage = () => {
                onAction('extractPage', { pageNumber: currentPage });
            };
            
            const handleProtect = () => {
                if (!password) {
                    alert('Please enter a password');
                    return;
                }
                
                onAction('protect', { password });
            };
            
            const handleAddWatermark = () => {
                if (!watermarkText) {
                    alert('Please enter watermark text');
                    return;
                }
                
                onAction('addWatermark', { 
                    text: watermarkText, 
                    position: watermarkPosition 
                });
            };
            
            return (
                <div className="pdf-tools">
                    <h3>PDF Tools</h3>
                    
                    <div className="tool-section">
                        <h4>Add Text</h4>
                        <input 
                            type="text" 
                            value={text} 
                            onChange={(e) => setText(e.target.value)}
                            placeholder="Enter text"
                        />
                        <input 
                            type="number" 
                            value={fontSize} 
                            onChange={(e) => setFontSize(e.target.value)}
                            placeholder="Font size"
                            min="8"
                            max="72"
                        />
                        <input 
                            type="color" 
                            value={fontColor} 
                            onChange={(e) => setFontColor(e.target.value)}
                        />
                        <button onClick={handleAddText}>Add Text to Page</button>
                    </div>

                    <div className="tool-section">
                        <h4>Rotate Page</h4>
                        <div className="button-group">
                            <button onClick={() => handleRotate('left')}>Rotate Left</button>
                            <button onClick={() => handleRotate('right')}>Rotate Right</button>
                        </div>
                    </div>

                    <div className="tool-section">
                        <h4>Extract Page</h4>
                        <button onClick={handleExtractPage}>Extract Current Page</button>
                    </div>

                    <div className="tool-section">
                        <h4>Protect PDF</h4>
                        <input 
                            type="password" 
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            placeholder="Enter password" 
                        />
                        <button onClick={handleProtect}>Protect PDF</button>
                    </div>

                    <div className="tool-section">
                        <h4>Add Watermark</h4>
                        <input 
                            type="text" 
                            value={watermarkText}
                            onChange={(e) => setWatermarkText(e.target.value)}
                            placeholder="Watermark text" 
                        />
                        <select 
                            value={watermarkPosition}
                            onChange={(e) => setWatermarkPosition(e.target.value)}
                        >
                            <option value="diagonal">Diagonal</option>
                            <option value="horizontal">Horizontal</option>
                            <option value="vertical">Vertical</option>
                        </select>
                        <button onClick={handleAddWatermark}>Add Watermark</button>
                    </div>
                </div>
            );
        }
        
        // Image Tools Component
        function ImageTools({ onAction, onExport }) {
            const [brightness, setBrightness] = useState(100);
            const [contrast, setContrast] = useState(100);
            const [saturation, setSaturation] = useState(100);
            const [text, setText] = useState('');
            const [textColor, setTextColor] = useState('#000000');
            const [filter, setFilter] = useState('none');
            const [resizeWidth, setResizeWidth] = useState('');
            const [resizeHeight, setResizeHeight] = useState('');
            const [drawColor, setDrawColor] = useState('#000000');
            const [drawWidth, setDrawWidth] = useState(5);
            
            const handleAdjustment = (type, value) => {
                onAction('adjust', { [type]: value });
            };
            
            const handleRotate = (direction) => {
                onAction('rotate', { direction });
            };
            
            const handleApplyFilter = () => {
                if (filter !== 'none') {
                    onAction('filter', { filter });
                }
            };
            
            const handleResize = () => {
                if (resizeWidth && resizeHeight) {
                    onAction('resize', { 
                        width: parseInt(resizeWidth), 
                        height: parseInt(resizeHeight) 
                    });
                }
            };
            
            const handleAddText = () => {
                if (!text) {
                    alert('Please enter text');
                    return;
                }
                
                onAction('addText', { 
                    text, 
                    position: { x: 50, y: 50 }, 
                    color: textColor 
                });
            };
            
            const handleDraw = () => {
                onAction('draw', { color: drawColor, width: parseInt(drawWidth) });
            };
            
            return (
                <div className="image-tools">
                    <h3>Image Tools</h3>
                    
                    <div className="tool-section">
                        <h4>Adjustments</h4>
                        <div className="slider-group">
                            <label>Brightness: {brightness}%</label>
                            <input 
                                type="range" 
                                min="0" 
                                max="200" 
                                value={brightness}
                                onChange={(e) => {
                                    setBrightness(e.target.value);
                                    handleAdjustment('brightness', e.target.value);
                                }}
                            />
                        </div>
                        
                        <div className="slider-group">
                            <label>Contrast: {contrast}%</label>
                            <input 
                                type="range" 
                                min="0" 
                                max="200" 
                                value={contrast}
                                onChange={(e) => {
                                    setContrast(e.target.value);
                                    handleAdjustment('contrast', e.target.value);
                                }}
                            />
                        </div>
                        
                        <div className="slider-group">
                            <label>Saturation: {saturation}%</label>
                            <input 
                                type="range" 
                                min="0" 
                                max="200" 
                                value={saturation}
                                onChange={(e) => {
                                    setSaturation(e.target.value);
                                    handleAdjustment('saturation', e.target.value);
                                }}
                            />
                        </div>
                    </div>

                    <div className="tool-section">
                        <h4>Rotate</h4>
                        <div className="button-group">
                            <button onClick={() => handleRotate('left')}>Rotate Left</button>
                            <button onClick={() => handleRotate('right')}>Rotate Right</button>
                        </div>
                    </div>

                    <div className="tool-section">
                        <h4>Add Text</h4>
                        <input 
                            type="text" 
                            value={text}
                            onChange={(e) => setText(e.target.value)}
                            placeholder="Enter text"
                        />
                        <input 
                            type="color" 
                            value={textColor}
                            onChange={(e) => setTextColor(e.target.value)}
                        />
                        <button onClick={handleAddText}>Add Text</button>
                    </div>

                    <div className="tool-section">
                        <h4>Filters</h4>
                        <select 
                            value={filter} 
                            onChange={(e) => setFilter(e.target.value)}
                        >
                            <option value="none">None</option>
                            <option value="grayscale">Grayscale</option>
                            <option value="sepia">Sepia</option>
                            <option value="invert">Invert</option>
                            <option value="blur">Blur</option>
                            <option value="sharpen">Sharpen</option>
                        </select>
                        <button onClick={handleApplyFilter}>Apply Filter</button>
                    </div>

                    <div className="tool-section">
                        <h4>Resize</h4>
                        <div className="input-group">
                            <input 
                                type="number" 
                                value={resizeWidth}
                                onChange={(e) => setResizeWidth(e.target.value)}
                                placeholder="Width" 
                            />
                            <span>×</span>
                            <input 
                                type="number" 
                                value={resizeHeight}
                                onChange={(e) => setResizeHeight(e.target.value)}
                                placeholder="Height" 
                            />
                        </div>
                        <button onClick={handleResize}>Resize</button>
                    </div>

                    <div className="tool-section">
                        <h4>Draw</h4>
                        <div className="input-group">
                            <input 
                                type="color" 
                                value={drawColor}
                                onChange={(e) => setDrawColor(e.target.value)}
                            />
                            <input 
                                type="number" 
                                value={drawWidth}
                                onChange={(e) => setDrawWidth(e.target.value)}
                                placeholder="Width" 
                                min="1"
                                max="20"
                            />
                        </div>
                        <button onClick={handleDraw}>Enable Drawing</button>
                    </div>
                    
                    <div className="tool-section">
                        <h4>Export</h4>
                        <button onClick={onExport}>Download Edited Image</button>
                    </div>
                </div>
            );
        }
        
        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
